#include <iostream>
#include <fstream>
#include <exception>
#include <string>

#include <csignal>

#include <jubatus/client.hpp>
#include <pficommon/text/json.h>
#include "mist.hpp"

using namespace std;
using namespace pfi::lang;
using jubatus::client::common::datum;
using jubatus::classifier::client::classifier;
using jubatus::classifier::labeled_datum;

namespace {
const string kName = "test";
const double kTimeout = 1.0;
}

#define STRING(...) #__VA_ARGS__

int main(int argc, char *argv[])
{
  using pfi::text::json::json;

  // portable code for socket write(2) MSG_NOSIGNAL
  if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
    perror("ignore SIGPIPE");
    return -1;
  }

  if (argc < 4) {
    cout << "./ml_train <config.json> <train.csv> <mist_dir>" << endl;
    return -1;
  }

  ifstream ifs(argv[1]);
  pfi::text::json::json config_json;
  try {
    ifs >> config_json;
  } catch (const std::exception& e) {
    cerr << "failed to read " << argv[1] << ": " << e.what() << endl;
    return -1;
  }


  string host;
  int port;
  try {
    using pfi::text::json::json_cast;

    host = json_cast<string>(config_json["host"]);
    port = json_cast<int>(config_json["port"]);
  } catch (const std::exception& e) {
    cerr << "failed to read config " << argv[1] << ": " << e.what() << endl;
    return -1;
  }

  try {
    classifier client(host, port, kName, kTimeout);

    // start train
    cerr << "Loading.. " << argv[2] << endl;
    vector<sample_type> targets = load_csv(argv[2]);
    cerr << "Target size: " << targets.size() << endl;

    vector<sample_type>::iterator it = targets.begin(), end = targets.end();
    for (; it != end; ++it) {
      string path = argv[3];
      path += "/";
      path += it->sha1;
      path += ".";
      path += it->label;

      vector<labeled_datum> data;
      datum d = { load_mist(path), vector<pair<string, double> >() };
      data.push_back(labeled_datum(it->label, d));

      client.train(data);
    }

  } catch (const msgpack::rpc::rpc_error& e) {
    cerr << "rpc_error: " << e.what() << endl;
  } catch (const exception& e) {
    cerr << "error: " << e.what() << endl;
  } catch (...) {
    cerr << "unhandled exception raised" << endl;
  }

  return 0;
}
