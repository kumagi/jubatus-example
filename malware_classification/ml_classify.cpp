#include <iostream>
#include <fstream>
#include <exception>
#include <string>
#include <algorithm>
#include <functional>
#include <vector>

#include <csignal>

#include <jubatus/client.hpp>
#include <pficommon/text/json.h>
#include "mist.hpp"

using namespace std;
using namespace pfi::lang;
using jubatus::common::datum;
using jubatus::classifier::estimate_result;
using jubatus::classifier::client::classifier;

namespace {
const string kName = "test";
const double kTimeout = 1.0;
}

bool estimate_compare(const estimate_result& lhs, const estimate_result& rhs)
{
  return rhs.score < rhs.score;
}

int main(int argc, char *argv[])
{
  using pfi::text::json::json;

  // portable code for socket write(2) MSG_NOSIGNAL
  if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
    perror("ignore SIGPIPE");
    return -1;
  }

  if (argc < 4) {
    cout << "./ml_classify <config.json> <train.csv> <mist_dir>" << endl;
    return -1;
  }

  ifstream ifs(argv[1]);
  pfi::text::json::json config_json;
  try {
    ifs >> config_json;
  } catch (const std::exception& e) {
    cerr << "failed to read " << argv[1] << ": " << e.what() << endl;
    return -1;
  }


  string host;
  int port;
  try {
    using pfi::text::json::json_cast;
    host = json_cast<string>(config_json["host"]);
    port = json_cast<int>(config_json["port"]);
  } catch (const std::exception& e) {
    cerr << "failed to read config " << argv[1] << ": " << e.what() << endl;
    return -1;
  }

  try {
    classifier client(host, port, kName, kTimeout);

    // start classify
    cerr << "Loading.. " << argv[2] << endl;
    vector<sample_type> targets = load_csv(argv[2]);
    cerr << "Target size: " << targets.size() << endl;

    vector<sample_type>::iterator it = targets.begin(), end = targets.end();
    for (; it != end; ++it) {
      string path = argv[3];
      path += "/";
      path += it->sha1;
      path += ".";
      path += it->label;

      vector<datum> data;
      vector<pair<string, string> > mist = load_mist(path);
      datum d = { load_mist(path), vector<pair<string, double> >() };
      data.push_back(d);

      vector<vector<estimate_result> > all_result = client.classify(data);

      // print json
      for (size_t i = 0, res_size = all_result.size(); i < res_size; ++i) {
        using namespace pfi::text::json;

        vector<estimate_result>& result = all_result[i];
        sort(result.begin(), result.end(), ptr_fun(estimate_compare));

        json res(new json_object());
        res.add("input", new json_string(it->sha1));
        res.add("label", new json_string(it->label));
        json js_score(new json_array());
        for (size_t j = 0; j < result.size(); ++j) {
          json o(new json_object());
          o.add(result[i].label, new json_float(result[i].score));
          js_score.add(o);
        }
        res.add("estimate", js_score);

        gen_print(cout, res, false, true);
        cout << endl;
      }
    }

  } catch (const msgpack::rpc::rpc_error& e) {
    cerr << "rpc_error: " << e.what() << endl;
  } catch (const exception& e) {
    cerr << "error: " << e.what() << endl;
  } catch (...) {
    cerr << "unhandled exception raised" << endl;
  }

  return 0;
}
